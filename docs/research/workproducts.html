<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-10-10">
<meta name="description" content="The Critical Alloy Research &amp; Discovery Lab (CARD Lab) at the University of Cincinnati develops and designs metallic materials critical for future economic and energy security.">

<title>Work Products – Critical Alloy Research &amp; Discovery Lab</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../files/site/3-clubs-favicon-r.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-9eeeae4dcae40c0b9d1d431f43e45de9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../site_libs/quarto-contrib/iconify-3.0.0/iconify-icon.min.js"></script>
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
.filter-group {
display: flex;
align-items: center;
gap: 0.0em;
}
.filter-group label {
margin: 0;
}
.filter-group input[type="text"],
.filter-group select {
    margin: 0;           /* remove extra spacing */
    padding: 0.0em 0.0em;
}
.filter-group button {
padding: 0.25em 0.75em; /* match select/input height */
line-height: 1.2;       /* match text vertical centering */
height: 2.2em;
}
.button-group {
display: flex;
align-items: center;
}

.controls {
display: flex;
flex-wrap: wrap;
justify-content: center;
align-items: center; /* Vertically center all controls */
gap: 0.0rem;
}

.controls label {
display: flex;
align-items: center; /* Align label text with control */
gap: 0.0rem;
}

.controls button {
line-height: 1.2;
}

/* Reset browser button quirks */
.controls button {
appearance: none;
-webkit-appearance: none; /* Safari */
-moz-appearance: none; /* Firefox */
border: 1px solid #ccc; /* Match input border */
background-color: #f8f8f8;
display: inline-flex;
align-items: center;  /* Center text vertically */
justify-content: center;
line-height: 1;
height: 0.7em;
cursor: pointer;
}

.controls input,
.controls select {
    height: 2.2em;
    line-height: 1.2;
    font-size: 0.9em;
    padding: 0.4em 0.8em; /* Same as button for alignment */
}

#controls-container {
display: flex;
flex-direction: row;
flex-wrap: wrap;
align-items: center;
justify-content: center;
gap: 1em;
margin-bottom: 1em;
font-size: 0.9em;
}

#filters-container {
display: flex;
flex-direction: row;
flex-wrap: wrap;
justify-content: center;
gap: 1em;
align-items: center;
}

#legend-container {
display: flex;
flex-direction: row;
flex-wrap: wrap;
justify-content: center;
gap: 1em;
align-items: center;
border: 1px solid #aaa;
border-radius: 6px;
padding: 10px 15px;
text-align: center;
background-color: #f9f9f9;
padding: 0.0em 0.0em;
}

label, input, select {
margin-right: 1em;
margin-top: 1em; /* Keep margin on label and select */
}

button {
margin-right: 1em;
margin-top: 0; /* Remove margin-top on buttons */
vertical-align: middle;
padding: 0.0em 0.0em;
height: auto;           /* Let height adjust based on padding */
background-color: #f9f9f9;
color: black;              /* black text for contrast */
border: 1px solid #aaa;    /* subtle border */
border-radius: 4px;
cursor: pointer;
transition: background-color 0.3s ease;
}

button:hover {
background-color: #eadbc1;
}

.citation { margin-bottom: 1em; }
.italic { font-style: italic; }
.bold { font-weight: bold; }
.underline { text-decoration: underline; }
.center { display: block; margin-left: auto; margin-right: auto; width: 15%; }
#bibliography {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    margin-top: 1em;
    margin-left: 1em;
    margin-right: 1em;
    }

/* Icon color classes */
.oa-icon {
margin-left: 6px;
vertical-align: middle;
display: inline-flex;
align-items: center;
}
.oa-gold { color: #FFD700; }
.oa-green { color: #2e7d32; }
.oa-bronze { color: #cd7f32; }
.oa-hybrid { color: #ff8f00; }
.oa-diamond { color: #b9f2ff; }
.oa-unknown { color: #1e88e5; }

.pdf-icon {
margin-left: 4px;
color: #e00122;
vertical-align: middle;
display: inline-flex;
align-items: center;
}
</style>

<script>
window.MathJax = {
    tex: {
    inlineMath: [['$', '$']],
    displayMath: [['$$', '$$']]
    },
    svg: { fontCache: 'global' }
};
</script>


<script type="text/javascript" src="//d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>


<script async="" src="https://badge.dimensions.ai/badge.js" charset="utf-8"></script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async=""></script>


<script src="https://code.iconify.design/2/2.2.1/iconify.min.js"></script>

<script>
// Map OA status to CSS class name
function oaColorClass(status) {
    switch (status) {
    case 'gold': return 'oa-gold';
    case 'green': return 'oa-green';
    case 'bronze': return 'oa-bronze';
    case 'hybrid': return 'oa-hybrid';
    case 'diamond': return 'oa-diamond';
    default: return 'oa-unknown';
    }
}

// Set loading message dynamically based on group ID
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('loadingMessage').innerHTML = `<em>Please wait. Loading content from the <a href="https://www.zotero.org/groups/${ZOTERO_GROUP_ID}/" target="_blank">CARD group Zotero library...</a></em>`;});
</script>


<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="Work Products – Critical Alloy Research &amp; Discovery Lab">
<meta property="og:site_name" content="Critical Alloy Research &amp; Discovery Lab">
</head>

<body class="nav-sidebar docked nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="https://www.uc.edu" class="navbar-brand navbar-brand-logo">
    <img src="../files/brand/uc_white.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="https://www.uc.edu">
    <span class="navbar-title">Critical Alloy Research &amp; Discovery Lab</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../index.html" aria-current="page"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../people/current.html"> 
<span class="menu-text">People</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../research/workproducts.html"> 
<span class="menu-text">Work Products</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../capabilities/index.html"> 
<span class="menu-text">Capabilities</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <div class="dropdown">
      <a href="" title="" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label=""><i class="bi bi-github"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://github.com/paytonej/card-lab-website">
            Source Code
            </a>
          </li>
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://github.com/paytonej/card-lab-website/issues">
            Report a Bug
            </a>
          </li>
      </ul>
    </div>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../research/workproducts.html">Work Products</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../index.html" class="sidebar-logo-link">
      <img src="../files/site/hugeicons--elearning-exchange-48-ucred.svg" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../research/workproducts.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Work Products</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../research/scientometrics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Scientometrics</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Work Products</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 10, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="section" class="level2 fill" width="200px">
<h2 class="fill anchored" width="200px" data-anchor-id="section"></h2>
<div id="work-products-content">
<div id="controls-container">
  
    <!-- Filters container -->
    <div id="filters-container">

        <div class="filter-group">
            <label for="yearFilter">Year:</label>
            <select id="yearFilter">
                <option value="">All</option>
            </select>
        </div>

        <div class="filter-group">
            <label for="typeFilter">Type:</label>
            <select id="typeFilter">
                <option value="">Journal Article</option>
            </select>
        </div>

        <div class="filter-group">
            <label for="searchInput" style="white-space: nowrap;">Search:</label>
            <input type="text" id="searchInput" placeholder="author, title, keyword">
        </div>

        <div class="filter-group">
            <button id="exportBibtex">Export to BibTeX</button>
        </div>
    </div> <!-- End filters container -->

    <div id="legend-container" min-width="190px" max-width="300px" min-height="200px" max-height="200px" flex-shrink="0">
            <strong style="margin-bottom: 8px; font-size: 1em;">Icon Legend</strong>
            <div style="align-items: center; gap: 0.25em;">
                    <span class="iconify oa-icon oa-unknown" data-icon="academicons:open-access" data-width="20" data-height="20"></span>Open Access <a href="https://help.openalex.org/hc/en-us/articles/24347035046295-Open-Access-OA" target="_blank"><em>(Color Key)</em></a>
            </div>
            <div style="align-items: center; gap: 0.25em;">
                <span class="iconify pdf-icon" data-icon="mdi:file-pdf-box" data-width="20" data-height="20"></span>PDF Direct Download
            </div>
        </div> <!-- End icon legend items list -->
    </div> <!-- End icon legend -->
</div> <!-- End controls container --> 
<script>

    const ZOTERO_GROUP_ID = 5985739;

    let zoteroItems = [];
    
    // --- Begin helper functions ---
    
    const validTypes = new Set([
    'artwork','audioRecording','bill','blogPost','book','bookSection','case','computerProgram',
    'conferencePaper','dictionaryEntry','document','email','encyclopediaArticle','film','forumPost',
    'hearing','instantMessage','interview','journalArticle','letter','magazineArticle','manuscript',
    'map','newspaperArticle','patent','podcast','presentation','radioBroadcast','report','statute',
    'thesis','tvBroadcast','videoRecording','webpage'
    ]);

    const typeLabels = {
    artwork: 'Artwork', audioRecording: 'Audio Recording', bill: 'Bill', blogPost: 'Blog Post', 
    book: 'Book', bookSection: 'Book Section', case: 'Legal Case', computerProgram: 'Software',
    conferencePaper: 'Conference Paper', dictionaryEntry: 'Dictionary Entry', document: 'Document',
    email: 'Email', encyclopediaArticle: 'Encyclopedia Article', film: 'Film', forumPost: 'Forum Post',
    hearing: 'Hearing', instantMessage: 'Instant Message', interview: 'Interview', journalArticle: 'Journal Article',
    letter: 'Letter', magazineArticle: 'Magazine Article', manuscript: 'Manuscript', map: 'Map',
    newspaperArticle: 'Newspaper Article', patent: 'Patent', podcast: 'Podcast', presentation: 'Presentation',
    radioBroadcast: 'Radio Broadcast', report: 'Report', statute: 'Statute', thesis: 'Thesis',
    tvBroadcast: 'TV Broadcast', videoRecording: 'Video Recording', webpage: 'Web Page'
    };
    
    async function fetchZoteroItems() {
    const response = await fetch(`https://api.zotero.org/groups/${ZOTERO_GROUP_ID}/items?format=json&limit=5000`);
    if (!response.ok) throw new Error(`Error fetching data: ${response.statusText}`);
    return response.json();
    }
    
    function parseDate(dateStr) {
        if (!dateStr || typeof dateStr !== 'string') return null;
        dateStr = dateStr.trim();
        if (dateStr.includes('/')) dateStr = dateStr.split('/')[0].trim();
        const seasonMap = { spring: '03-01', summer: '06-01', fall: '09-01', autumn: '09-01', winter: '12-01' };
        const seasonMatch = dateStr.match(/(spring|summer|fall|autumn|winter)\s+(\d{4})/i);
        if (seasonMatch) return new Date(`${seasonMatch[2]}-${seasonMap[seasonMatch[1].toLowerCase()]}`);
        const monthMatch = dateStr.match(/^(January|February|March|April|May|June|July|August|September|October|November|December|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec)\s+(\d{4})$/i);
        if (monthMatch) {
            const fullMonth = { Jan: '01', Feb: '02', Mar: '03', Apr: '04', May: '05', Jun: '06', Jul: '07', Aug: '08', Sep: '09', Sept: '09', Oct: '10', Nov: '11', Dec: '12',
            January: '01', February: '02', March: '03', April: '04', May: '05', June: '06', July: '07', August: '08', September: '09', October: '10', November: '11', December: '12' };
            return new Date(`${monthMatch[2]}-${fullMonth[monthMatch[1]]}-01`);
        }
        if (/^\d{4}-\d{2}-\d{2}/.test(dateStr)) return new Date(dateStr.substring(0, 10));
        if (/^\d{4}-\d{2}/.test(dateStr)) return new Date(`${dateStr}-01`);
        if (/^\d{4}/.test(dateStr)) return new Date(`${dateStr}-01-01`);
        return null;
    }
    function extractYear(dateStr) { const d = parseDate(dateStr); return d ? d.getFullYear().toString() : ''; }

    function extractSortDate(dateStr) { const d = parseDate(dateStr); return d ? d.getTime() : 0; }

    function toSentenceCasePreserveBracesAcronymsElements(title) {
        if (!title) return "";

        const elementSymbols = new Set([
            "H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca",
            "Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr",
            "Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba",
            "La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","W",
            "Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U",
            "Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr","Rf","Db","Sg","Bh","Hs","Mt","Ds",
            "Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og"
        ]);

        function isChemicalLaTeXFormula(token) {
            return /^(?:[A-Z][a-z]?(?:\$_\{?\d+\}?\$|\$\^\{?[^\}]+\}?\$)*)+$/.test(token)
            && [...token.matchAll(/[A-Z][a-z]?/g)].every(m => elementSymbols.has(m[0]));
        }

        function isElementNumericCompound(token) {
            const m = token.match(/^(\d+%?|\d*%?)([A-Za-z0-9]+)$/);
            if (!m) return false;
            const body = m[2];
            const parts = [...body.matchAll(/([A-Z][a-z]?|\d+)/g)];
            let idx = 0;
            for (let p of parts) {
            const part = p[0];
            if (!/^\d+$/.test(part) && !elementSymbols.has(part)) return false;
            if (p.index !== idx) return false;
            idx += part.length;
            }
            return idx === body.length;
        }

        // store preserved fragments (WITHOUT braces)
        const preserved = [];

        // 1) Replace {inner} -> ___PRESERVEk___ and store inner (no braces)
        const braceReplaced = title.replace(/\{([^}]+)\}/g, (_, match) => {
            preserved.push(match);
            return `___PRESERVE${preserved.length - 1}___`;
        });

        // 2) Also optionally preserve parenthetical acronyms like (ABC)
        const acronymParenReplaced = braceReplaced.replace(/\(([A-Z][A-Z0-9-]*s?)\)/g, (_, match) => {
            preserved.push(`(${match})`);
            return `___PRESERVE${preserved.length - 1}___`;
        });

        // 3) Split into tokens but keep placeholders as separate tokens so they are not mangled
        const tokens = acronymParenReplaced.split(/(___PRESERVE\d+___|\s+|[-–—:;,\(\)])/);

        // 4) Map tokens to sentence case while never altering placeholder tokens
        const result = tokens.map((token, idx) => {
            if (!token) return "";

            // If the token is exactly a placeholder, keep it as-is (restore later)
            const ph = token.match(/^___PRESERVE(\d+)___$/);
            if (ph) return token;

            // whitespace or punctuation -> keep unchanged
            if (/^\s+$/.test(token) || /^[-–—:;,\(\)]$/.test(token)) return token;

            // keep ALL-CAPS acronyms and chemical-like tokens unchanged
            if (/^[A-Z]{2,}$/.test(token) || isElementNumericCompound(token) || isChemicalLaTeXFormula(token)) {
            return token;
            }

            // determine if this token should be sentence-start-cased:
            // look backwards for the nearest non-empty token to see if it ends a sentence
            let prev = null;
            for (let j = idx - 1; j >= 0; --j) {
            if (tokens[j]) { prev = tokens[j]; break; }
            }
            const prevEndsSentence = !prev || /[.?!]\s*$/.test(prev);

            if (prev === null || prevEndsSentence) {
            return token.charAt(0).toUpperCase() + token.slice(1).toLowerCase();
            } else {
            return token.toLowerCase();
            }
        }).join("");

        // 5) Restore preserved fragments (WITHOUT the original braces)
        return result.replace(/___PRESERVE(\d+)___/g, (_, i) => preserved[parseInt(i, 10)]);
    }

    function populateFilters(items) {
        const years = new Set(), types = new Set();
        items.forEach(item => {
            const year = extractYear(item.data.date);
            if (year) years.add(year);
            if (item.data.itemType) types.add(item.data.itemType);
        });

        // Year filter: clear existing options
        const yearFilter = document.getElementById('yearFilter');
        yearFilter.innerHTML = '';

        // Add 'All' option first
        const allOption = document.createElement('option');
        allOption.value = '';
        allOption.textContent = 'All';
        yearFilter.appendChild(allOption);

        // Add sorted year options
        Array.from(years).sort((a, b) => b - a).forEach(year => {
            const option = document.createElement('option');
            option.value = year;
            option.textContent = year;
            yearFilter.appendChild(option);
        });

        // Type filter: similar handling
        const typeFilter = document.getElementById('typeFilter');
        typeFilter.innerHTML = '';

        const allTypeOption = document.createElement('option');
        allTypeOption.value = '';
        allTypeOption.textContent = 'All';
        typeFilter.appendChild(allTypeOption);

        Array.from(types).sort().forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = typeLabels[type] || type;
            if (type === 'journalArticle') option.selected = true;
            typeFilter.appendChild(option);
        });
    }

    function formatAuthors(creators) {
        if (!creators) return '';
        return creators.map(c => c.name ? c.name : c.firstName && c.lastName ?
            `${c.firstName.split(/\s+/).map(name => name.charAt(0).toUpperCase() + '.').join(' ')} ${c.lastName}` :
            c.lastName || c.firstName || '').filter(name => name.trim() !== '').join(', ');
    }

    function escapeBibTeX(str) { return str?.replace(/([{}%&_#])/g, '\\$1') || ''; }

    function formatCitation(item, index, total) {
        const d = item.data, creators = d.creators || [], authors = creators.filter(c => c.creatorType === 'author'), editors = creators.filter(c => c.creatorType === 'editor');
        let mainContributors = (d.itemType === 'computerProgram' || d.itemType === "presentation") ? creators : authors;
        const formattedAuthors = formatAuthors(mainContributors);
        const formattedEditors = editors.length > 0 ? formatAuthors(editors) : null;
        const year = extractYear(d.date), number = total - index, sentenceTitle = toSentenceCasePreserveBracesAcronymsElements(d.title);
        let citation = `[${number}] ${formattedAuthors}`;
        if (d.itemType === 'computerProgram') citation += ` (${mainContributors.length === 1 ? 'contributor' : 'contributors'})`;
        citation += `. “${sentenceTitle}.”`;
        if (d.itemType === 'book') citation += ` <span class="underline">${d.bookTitle || d.title}</span>`;
        if (d.itemType === 'thesis') { citation += ` ${d.thesisType || "Thesis"}`; if (d.university) citation += `, ${d.university}`; if (d.place) citation += `, ${d.place}`; }
        if (d.itemType === 'report') { if (d.reportNumber) citation += ` Report No. ${d.reportNumber}`; if (d.place) citation += `, ${d.place}`; if (d.institution) citation += `: ${d.institution}.`; }
        if (d.itemType === 'computerProgram') { if (d.version) citation += ` Version ${d.version}`; if (d.date) citation += ` ${d.date}`; if (d.place) citation += `, ${d.place}`; if (d.institution) citation += `: ${d.institution}.`; }
        if (d.itemType === 'conferencePaper' || d.itemType === 'proceedingsArticle') { if (d.proceedingsTitle) citation += ` In <span class="italic">${d.proceedingsTitle}</span>`; if (editors.length > 0) citation += `. ${formattedEditors} (${editors.length === 1 ? 'ed.' : 'eds.'})`; if (d.place) citation += `. ${d.place}`; if (d.publisher) citation += `: ${d.publisher}`; }
        if (d.publicationTitle) citation += ` <span class="italic">${d.publicationTitle}</span>`;
        if (d.volume) citation += ` <span class="bold">${d.volume}</span>`;
        if (d.issue) citation += `(${d.issue})`;
        if (d.itemType === 'presentation') { if (d.presentationType) citation += ` ${d.presentationType}`; if (d.meetingName) citation += ` at <span class="italic">${d.meetingName}</span>`; if (d.place) citation += `, ${d.place}`; if (d.date) citation += `, ${d.date}`; }
        if (year) citation += ` (${year})`;
        if (d.pages) citation += ` p.${d.pages}`;
        if (!citation.trim().endsWith('.')) citation += '.';
        if (d.DOI) citation += ` <a href="https://doi.org/${d.DOI}" target="_blank">doi:${d.DOI}</a>`;
        else if (d.url) citation += ` <a href="${d.url}" target="_blank">${d.url}</a>`;
        return `<div class="citation">${citation}</div>`;
    }

    function convertToBibTeX(d) {
        const type = d.itemType || 'article', fields= [], key = `${d.creators?.[0]?.lastName || 'unknown'}${extractYear(d.date)}`;
        if (d.title) fields.push(`  title = {${escapeBibTeX(d.title)}}`);
        if (d.creators) { const authors = d.creators.map(c => `${c.lastName}, ${c.firstName}`).join(' and '); if (authors) fields.push(`  author = {${authors}}`); }
        if (d.publicationTitle) fields.push(`  journal = {${d.publicationTitle}}`);
        if (d.bookTitle) fields.push(`  booktitle = {${d.bookTitle}}`);
        if (d.university) fields.push(`  school = {${d.university}}`);
        if (d.date) fields.push(`  year = {${extractYear(d.date)}}`);
        if (d.volume) fields.push(`  volume = {${d.volume}}`);
        if (d.issue) fields.push(`  number = {${d.issue}}`);
        if (d.pages) fields.push(`  pages = {${d.pages}}`);
        if (d.DOI) fields.push(`  doi = {${d.DOI}}`);
        return `@${type}{${key},\n${fields.join(',\n')}\n}`;
    }
    // --- End helper functions ---

    // --- Begin main function that displays filtered bibliography
    async function displayFilteredBibliography() {
    const yearVal = document.getElementById('yearFilter').value.toLowerCase();
    const typeVal = document.getElementById('typeFilter').value;
    const searchTerm = document.getElementById('searchInput').value.toLowerCase();
    const container = document.getElementById('bibliography');

    const filtered = zoteroItems.filter(item => {
        const d = item.data;
        const year = extractYear(d.date);
        const matchesYear = yearVal ? year === yearVal : true;
        const matchesType = typeVal ? d.itemType === typeVal : true;
        const authors = formatAuthors(d.creators).toLowerCase();
        const title = (d.title || '').toLowerCase();
        const pub = (d.publicationTitle || '').toLowerCase();
        const tags = (d.tags || []).map(tag => tag.tag.toLowerCase()).join(' ');
        const matchesSearch = !searchTerm ||
        authors.includes(searchTerm) ||
        title.includes(searchTerm) ||
        pub.includes(searchTerm) ||
        tags.includes(searchTerm);
        return matchesYear && matchesType && matchesSearch;
    });

    // Render citations without OA icons yet
    container.innerHTML = filtered.map((item, index) =>
        formatCitation(item, index, filtered.length)
    ).join('') || '<p>No matching entries found.</p>';

    // Query OpenAlex for DOIs with OA data
    const doiMap = {};
    const dois = filtered
        .map((item, idx) => {
        if (item.data.DOI) {
            const doi = item.data.DOI.toLowerCase();
            doiMap[doi] = idx;
            return doi;
        }
        return null;
        })
        .filter(Boolean);

        if (dois.length > 0) {
        try {
            // Helper to split into chunks of max size n
            const chunkArray = (arr, size) =>
            arr.reduce((acc, _, i) => (i % size ? acc : [...acc, arr.slice(i, i + size)]), []);

            const doiChunks = chunkArray(dois, 100);

            const fetchPromises = doiChunks.map(async chunk => {
            const filterParam = chunk.map(d => `${encodeURIComponent(d)}`).join('|');
            const apiUrl = `https://api.openalex.org/works?filter=doi:${filterParam}`;
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`OpenAlex fetch failed (${response.status})`);
                const data = await response.json();
                return data.results; // array of works
            } catch (err) {
                console.warn(err.message);
                return [];
            }
            });

            const chunkResults = await Promise.all(fetchPromises);
            const works = chunkResults.flat();

            works.forEach(work => {
            const doi = (work.doi || '').replace(/^https?:\/\/doi.org\//, '').toLowerCase();
            const index = doiMap[doi];
            if (index === undefined) return;

            const citationbadge = container.children[index];

            // --- Scientometric badges ---
            if (doi) {
                const altmetricBadge = document.createElement('span');
                altmetricBadge.className = 'altmetric-embed';
                altmetricBadge.setAttribute('data-badge-type', '4');
                altmetricBadge.setAttribute('data-doi', doi);
                altmetricBadge.setAttribute('data-hide-no-mentions', 'true');
                altmetricBadge.style.display = 'inline-block';
                altmetricBadge.style.marginLeft = '6px';
                citationbadge.appendChild(altmetricBadge);

                const dimensionsBadge = document.createElement('span');
                dimensionsBadge.className = "__dimensions_badge_embed__";
                dimensionsBadge.setAttribute('data-style', 'small_rectangle');
                dimensionsBadge.setAttribute('data-doi', doi);
                dimensionsBadge.setAttribute('data-hide-zero-citations', 'true');
                dimensionsBadge.style.display = 'inline-block';
                dimensionsBadge.style.marginLeft = '6px';
                citationbadge.appendChild(dimensionsBadge);

                if (typeof _altmetric_embed_init === 'function') _altmetric_embed_init();
                if (window.DimensionsBadge?.render) window.DimensionsBadge.render();
            }

            // --- OA icon & PDF detection ---
            if (work.open_access?.is_oa && work.open_access.oa_url) {
                const oaUrl = work.open_access.oa_url;
                const oaStatus = work.open_access.oa_status || 'unknown';

                const oaLink = document.createElement('a');
                oaLink.href = oaUrl;
                oaLink.target = '_blank';
                oaLink.className = 'oa-icon-link oa-icon ' + oaColorClass(oaStatus);

                const oaIcon = document.createElement('span');
                oaIcon.className = 'iconify';
                oaIcon.setAttribute('data-icon', 'academicons:open-access');
                oaIcon.setAttribute('data-width', '20');
                oaIcon.setAttribute('data-height', '20');

                oaLink.appendChild(oaIcon);
                citationbadge.appendChild(oaLink);
                Iconify.scan();

                const oaUrls = work.open_access?.oa_urls || [];
                const pdfRegex = /\.pdf(\?|$)/i;
                let pdfUrl = null;
                if (oaUrls.length > 0) {
                const pdfEntry = oaUrls.find(entry => pdfRegex.test(entry.url));
                if (pdfEntry) pdfUrl = pdfEntry.url;
                }
                if (!pdfUrl && pdfRegex.test(oaUrl)) pdfUrl = oaUrl;
                if (pdfUrl) {
                const pdfLink = document.createElement('a');
                pdfLink.href = pdfUrl;
                pdfLink.target = '_blank';
                pdfLink.className = 'pdf-icon-link pdf-icon';

                const pdfIcon = document.createElement('span');
                pdfIcon.className = 'iconify';
                pdfIcon.setAttribute('data-icon', 'mdi:file-pdf-box');
                pdfIcon.setAttribute('data-width', '20');
                pdfIcon.setAttribute('data-height', '20');

                pdfLink.appendChild(pdfIcon);
                citationbadge.appendChild(pdfLink);
                Iconify.scan();
                }
            }
            });

        } catch (error) {
            console.error('Error fetching OA data:', error);
        }
        }

    if (window.MathJax?.typesetPromise) {
        MathJax.typesetPromise();
    }
    }

    // Export filtered bibliography to BibTeX
    document.getElementById('exportBibtex').addEventListener('click', () => {
    const yearVal = document.getElementById('yearFilter').value;
    const typeVal = document.getElementById('typeFilter').value;
    const filtered = zoteroItems.filter(item => {
        const d = item.data;
        const year = extractYear(d.date);
        const matchesYear = yearVal ? year === yearVal : true;
        const matchesType = typeVal ? d.itemType === typeVal : true;
        return matchesYear && matchesType;
    });

    const bibtex = filtered.map(item => convertToBibTeX(item.data)).join('\n\n');
    const blob = new Blob([bibtex], { type: 'application/x-bibtex' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'bibliography.bib';
    a.click();
    URL.revokeObjectURL(url);
    });

    // Hook up filters & search
    document.getElementById('yearFilter').addEventListener('change', displayFilteredBibliography);
    document.getElementById('typeFilter').addEventListener('change', displayFilteredBibliography);
    document.getElementById('searchInput').addEventListener('input', displayFilteredBibliography);

    // Initial load
    async function displayBibliography() {
    try {
        const items = await fetchZoteroItems();
        const bibItems = items.filter(item => validTypes.has(item.data.itemType));
        bibItems.forEach(item => { item.sortDate = extractSortDate(item.data.date); });
        zoteroItems = bibItems.sort((a, b) => b.sortDate - a.sortDate);
        populateFilters(zoteroItems);
        await displayFilteredBibliography();
    } catch (err) {
        document.getElementById('bibliography').innerText = `Failed to load bibliography: ${err.message}`;
    }
    }

    displayBibliography();
</script>
<br>
<div id="bibliography" min-width="190px">
    <span class="loading-text" id="loadingMessage"></span>
</div>
</section></main></div>




 <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
 <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../easteregg.html">
<p><iconify-icon role="img" inline="" icon="game-icons:card-jack-diamonds" aria-label="Icon card-jack-diamonds from game-icons Iconify.design set." title="Icon card-jack-diamonds from game-icons Iconify.design set."></iconify-icon><iconify-icon role="img" inline="" icon="game-icons:card-ace-spades" aria-label="Icon card-ace-spades from game-icons Iconify.design set." title="Icon card-ace-spades from game-icons Iconify.design set."></iconify-icon><iconify-icon role="img" inline="" icon="game-icons:card-9-diamonds" aria-label="Icon card-9-diamonds from game-icons Iconify.design set." title="Icon card-9-diamonds from game-icons Iconify.design set."></iconify-icon></p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://www.zotero.org/groups/5985739/uc_card_lab/" target="_blank">
<p><iconify-icon role="img" inline="" icon="academicons:zotero-square" aria-label="Icon zotero-square from academicons Iconify.design set." title="Icon zotero-square from academicons Iconify.design set."></iconify-icon></p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/paytonej" target="_blank">
<p><iconify-icon role="img" inline="" icon="uiw:github" aria-label="Icon github from uiw Iconify.design set." title="Icon github from uiw Iconify.design set."></iconify-icon></p>
</a>
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 © October 10, 2025 Eric J Payton | 
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../impressum.html">
<p>Impressum</p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>