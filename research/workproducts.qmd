---
title: "Work Products"
jupyter: "card-lab"
format: html
toc: false
include-in-header:
    text: |
        <style>
        .filter-group {
        display: flex;
        align-items: center;
        gap: 0.0em;
        }
        .filter-group label {
        margin: 0;
        }
        .filter-group input[type="text"],
        .filter-group select {
            margin: 0;           /* remove extra spacing */
            padding: 0.0em 0.0em;
        }
        .filter-group button {
        padding: 0.25em 0.75em; /* match select/input height */
        line-height: 1.2;       /* match text vertical centering */
        height: 2.2em;
        }
        .button-group {
        display: flex;
        align-items: center;
        }

        .controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center; /* Vertically center all controls */
        gap: 0.0rem;
        }

        .controls label {
        display: flex;
        align-items: center; /* Align label text with control */
        gap: 0.0rem;
        }

        .controls button {
        line-height: 1.2;
        }

        /* Reset browser button quirks */
        .controls button {
        appearance: none;
        -webkit-appearance: none; /* Safari */
        -moz-appearance: none; /* Firefox */
        border: 1px solid #ccc; /* Match input border */
        background-color: #f8f8f8;
        display: inline-flex;
        align-items: center;  /* Center text vertically */
        justify-content: center;
        line-height: 1;
        height: 0.7em;
        cursor: pointer;
        }

        .controls input,
        .controls select {
            height: 2.2em;
            line-height: 1.2;
            font-size: 0.9em;   
            padding: 0.4em 0.8em; /* Same as button for alignment */
        }

        #controls-container {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        align-items: center;
        justify-content: center;
        gap: 1em;
        margin-bottom: 1em;
        font-size: 0.9em;  
        }

        #filters-container {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        gap: 1em;
        align-items: center;
        }

        #legend-container {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        gap: 1em;
        align-items: center;
        border: 1px solid #aaa;
        border-radius: 6px;
        padding: 10px 15px;
        text-align: center;
        background-color: #f9f9f9;
        padding: 0.0em 0.0em;
        }

        label, input, select {
        margin-right: 1em;
        margin-top: 1em; /* Keep margin on label and select */
        }

        button {
        margin-right: 1em;
        margin-top: 0; /* Remove margin-top on buttons */
        vertical-align: middle;
        padding: 0.0em 0.0em;
        height: auto;           /* Let height adjust based on padding */
        background-color: #f9f9f9;
        color: black;              /* black text for contrast */
        border: 1px solid #aaa;    /* subtle border */
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s ease;
        }

        button:hover {
        background-color: #eadbc1;
        }

        .citation { margin-bottom: 1em; }
        .italic { font-style: italic; }
        .bold { font-weight: bold; }
        .underline { text-decoration: underline; }
        .center { display: block; margin-left: auto; margin-right: auto; width: 15%; }
        #bibliography {         
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            margin-top: 1em; 
            margin-left: 1em; 
            margin-right: 1em; 
            }

        /* Icon color classes */
        .oa-icon {
        margin-left: 6px;
        vertical-align: middle;
        display: inline-flex;
        align-items: center;
        }
        .oa-gold { color: #FFD700; }
        .oa-green { color: #2e7d32; }
        .oa-bronze { color: #cd7f32; }
        .oa-hybrid { color: #ff8f00; }
        .oa-diamond { color: #b9f2ff; }
        .oa-unknown { color: #1e88e5; }

        .pdf-icon {
        margin-left: 4px;
        color: #e00122;
        vertical-align: middle;
        display: inline-flex;
        align-items: center;
        }
        </style>

        <script>
        window.MathJax = {
            tex: {
            inlineMath: [['$', '$']],
            displayMath: [['$$', '$$']]
            },
            svg: { fontCache: 'global' }
        };
        </script>
        
        <!-- Load Altmetric badges -->
        <script type="text/javascript" src="//d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
        
        <!-- Load DimensionsAI badges -->
        <script async src="https://badge.dimensions.ai/badge.js" charset="utf-8"></script>
        
        <!-- Load mathjax rendering of equations -->
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>

        <!-- Load Iconify inline SVG API and the icons we wnat to use-->
        <script src="https://code.iconify.design/2/2.2.1/iconify.min.js"></script>

        <script>
        // Map OA status to CSS class name
        function oaColorClass(status) {
            switch (status) {
            case 'gold': return 'oa-gold';
            case 'green': return 'oa-green';
            case 'bronze': return 'oa-bronze';
            case 'hybrid': return 'oa-hybrid';
            case 'diamond': return 'oa-diamond';
            default: return 'oa-unknown';
            }
        }
        
        // Set loading message dynamically based on group ID
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('loadingMessage').innerHTML = `<em>Please wait. Loading content from the <a href="https://www.zotero.org/groups/${ZOTERO_GROUP_ID}/" target="_blank">CARD group Zotero library...</a></em>`;});
        </script>
---

## {.fill width="200px"}
```{=html}
<div id="work-products-content">
<div id="controls-container">
  
    <!-- Filters container -->
    <div id="filters-container">

        <div class="filter-group">
            <label for="yearFilter">Year:</label>
            <select id="yearFilter">
                <option value="">All</option>
            </select>
        </div>

        <div class="filter-group">
            <label for="typeFilter">Type:</label>
            <select id="typeFilter">
                <option value="">Journal Article</option>
            </select>
        </div>

        <div class="filter-group">
            <label for="searchInput" style="white-space: nowrap;">Search:</label>
            <input type="text" id="searchInput" placeholder="author, title, keyword" />
        </div>

        <div class="filter-group">
            <button id="exportBibtex">Export to BibTeX</button>
        </div>
    </div> <!-- End filters container -->

    <div id="legend-container" min-width="190px" max-width="300px" min-height="200px" max-height= "200px" flex-shrink=0>
            <strong style="margin-bottom: 8px; font-size: 1em;">Icon Legend</strong>
            <div style="align-items: center; gap: 0.25em;">
                    <span class="iconify oa-icon oa-unknown" data-icon="academicons:open-access" data-width="20" data-height="20"></span>Open Access <a href="https://help.openalex.org/hc/en-us/articles/24347035046295-Open-Access-OA" target="_blank"><em>(Color Key)</em></a>
            </div>
            <div style="align-items: center; gap: 0.25em;">
                <span class="iconify pdf-icon" data-icon="mdi:file-pdf-box" data-width="20" data-height="20"></span>PDF Direct Download
            </div>
        </div> <!-- End icon legend items list -->
    </div> <!-- End icon legend -->
</div> <!-- End controls container --> 
<script>

    const ZOTERO_GROUP_ID = 5985739;

    let zoteroItems = [];
    
    // --- Begin helper functions ---
    
    const validTypes = new Set([
    'artwork','audioRecording','bill','blogPost','book','bookSection','case','computerProgram',
    'conferencePaper','dictionaryEntry','document','email','encyclopediaArticle','film','forumPost',
    'hearing','instantMessage','interview','journalArticle','letter','magazineArticle','manuscript',
    'map','newspaperArticle','patent','podcast','presentation','radioBroadcast','report','statute',
    'thesis','tvBroadcast','videoRecording','webpage'
    ]);

    const typeLabels = {
    artwork: 'Artwork', audioRecording: 'Audio Recording', bill: 'Bill', blogPost: 'Blog Post', 
    book: 'Book', bookSection: 'Book Section', case: 'Legal Case', computerProgram: 'Software',
    conferencePaper: 'Conference Paper', dictionaryEntry: 'Dictionary Entry', document: 'Document',
    email: 'Email', encyclopediaArticle: 'Encyclopedia Article', film: 'Film', forumPost: 'Forum Post',
    hearing: 'Hearing', instantMessage: 'Instant Message', interview: 'Interview', journalArticle: 'Journal Article',
    letter: 'Letter', magazineArticle: 'Magazine Article', manuscript: 'Manuscript', map: 'Map',
    newspaperArticle: 'Newspaper Article', patent: 'Patent', podcast: 'Podcast', presentation: 'Presentation',
    radioBroadcast: 'Radio Broadcast', report: 'Report', statute: 'Statute', thesis: 'Thesis',
    tvBroadcast: 'TV Broadcast', videoRecording: 'Video Recording', webpage: 'Web Page'
    };
    
    async function fetchZoteroItems() {
    const response = await fetch(`https://api.zotero.org/groups/${ZOTERO_GROUP_ID}/items?format=json&limit=5000`);
    if (!response.ok) throw new Error(`Error fetching data: ${response.statusText}`);
    return response.json();
    }
    
    function parseDate(dateStr) {
        if (!dateStr || typeof dateStr !== 'string') return null;
        dateStr = dateStr.trim();
        if (dateStr.includes('/')) dateStr = dateStr.split('/')[0].trim();
        const seasonMap = { spring: '03-01', summer: '06-01', fall: '09-01', autumn: '09-01', winter: '12-01' };
        const seasonMatch = dateStr.match(/(spring|summer|fall|autumn|winter)\s+(\d{4})/i);
        if (seasonMatch) return new Date(`${seasonMatch[2]}-${seasonMap[seasonMatch[1].toLowerCase()]}`);
        const monthMatch = dateStr.match(/^(January|February|March|April|May|June|July|August|September|October|November|December|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec)\s+(\d{4})$/i);
        if (monthMatch) {
            const fullMonth = { Jan: '01', Feb: '02', Mar: '03', Apr: '04', May: '05', Jun: '06', Jul: '07', Aug: '08', Sep: '09', Sept: '09', Oct: '10', Nov: '11', Dec: '12',
            January: '01', February: '02', March: '03', April: '04', May: '05', June: '06', July: '07', August: '08', September: '09', October: '10', November: '11', December: '12' };
            return new Date(`${monthMatch[2]}-${fullMonth[monthMatch[1]]}-01`);
        }
        if (/^\d{4}-\d{2}-\d{2}/.test(dateStr)) return new Date(dateStr.substring(0, 10));
        if (/^\d{4}-\d{2}/.test(dateStr)) return new Date(`${dateStr}-01`);
        if (/^\d{4}/.test(dateStr)) return new Date(`${dateStr}-01-01`);
        return null;
    }
    function extractYear(dateStr) { const d = parseDate(dateStr); return d ? d.getFullYear().toString() : ''; }

    function extractSortDate(dateStr) { const d = parseDate(dateStr); return d ? d.getTime() : 0; }

    function toSentenceCasePreserveBracesAcronymsElements(title) {
        if (!title) return "";

        const elementSymbols = new Set([
            "H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca",
            "Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr",
            "Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba",
            "La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","W",
            "Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U",
            "Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr","Rf","Db","Sg","Bh","Hs","Mt","Ds",
            "Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og"
        ]);

        function isChemicalLaTeXFormula(token) {
            return /^(?:[A-Z][a-z]?(?:\$_\{?\d+\}?\$|\$\^\{?[^\}]+\}?\$)*)+$/.test(token)
            && [...token.matchAll(/[A-Z][a-z]?/g)].every(m => elementSymbols.has(m[0]));
        }

        function isElementNumericCompound(token) {
            const m = token.match(/^(\d+%?|\d*%?)([A-Za-z0-9]+)$/);
            if (!m) return false;
            const body = m[2];
            const parts = [...body.matchAll(/([A-Z][a-z]?|\d+)/g)];
            let idx = 0;
            for (let p of parts) {
            const part = p[0];
            if (!/^\d+$/.test(part) && !elementSymbols.has(part)) return false;
            if (p.index !== idx) return false;
            idx += part.length;
            }
            return idx === body.length;
        }

        // store preserved fragments (WITHOUT braces)
        const preserved = [];

        // 1) Replace {inner} -> ___PRESERVEk___ and store inner (no braces)
        const braceReplaced = title.replace(/\{([^}]+)\}/g, (_, match) => {
            preserved.push(match);
            return `___PRESERVE${preserved.length - 1}___`;
        });

        // 2) Also optionally preserve parenthetical acronyms like (ABC)
        const acronymParenReplaced = braceReplaced.replace(/\(([A-Z][A-Z0-9-]*s?)\)/g, (_, match) => {
            preserved.push(`(${match})`);
            return `___PRESERVE${preserved.length - 1}___`;
        });

        // 3) Split into tokens but keep placeholders as separate tokens so they are not mangled
        const tokens = acronymParenReplaced.split(/(___PRESERVE\d+___|\s+|[-–—:;,\(\)])/);

        // 4) Map tokens to sentence case while never altering placeholder tokens
        const result = tokens.map((token, idx) => {
            if (!token) return "";

            // If the token is exactly a placeholder, keep it as-is (restore later)
            const ph = token.match(/^___PRESERVE(\d+)___$/);
            if (ph) return token;

            // whitespace or punctuation -> keep unchanged
            if (/^\s+$/.test(token) || /^[-–—:;,\(\)]$/.test(token)) return token;

            // keep ALL-CAPS acronyms and chemical-like tokens unchanged
            if (/^[A-Z]{2,}$/.test(token) || isElementNumericCompound(token) || isChemicalLaTeXFormula(token)) {
            return token;
            }

            // determine if this token should be sentence-start-cased:
            // look backwards for the nearest non-empty token to see if it ends a sentence
            let prev = null;
            for (let j = idx - 1; j >= 0; --j) {
            if (tokens[j]) { prev = tokens[j]; break; }
            }
            const prevEndsSentence = !prev || /[.?!]\s*$/.test(prev);

            if (prev === null || prevEndsSentence) {
            return token.charAt(0).toUpperCase() + token.slice(1).toLowerCase();
            } else {
            return token.toLowerCase();
            }
        }).join("");

        // 5) Restore preserved fragments (WITHOUT the original braces)
        return result.replace(/___PRESERVE(\d+)___/g, (_, i) => preserved[parseInt(i, 10)]);
    }

    function populateFilters(items) {
        const years = new Set(), types = new Set();
        items.forEach(item => {
            const year = extractYear(item.data.date);
            if (year) years.add(year);
            if (item.data.itemType) types.add(item.data.itemType);
        });

        // Year filter: clear existing options
        const yearFilter = document.getElementById('yearFilter');
        yearFilter.innerHTML = '';

        // Add 'All' option first
        const allOption = document.createElement('option');
        allOption.value = '';
        allOption.textContent = 'All';
        yearFilter.appendChild(allOption);

        // Add sorted year options
        Array.from(years).sort((a, b) => b - a).forEach(year => {
            const option = document.createElement('option');
            option.value = year;
            option.textContent = year;
            yearFilter.appendChild(option);
        });

        // Type filter: similar handling
        const typeFilter = document.getElementById('typeFilter');
        typeFilter.innerHTML = '';

        const allTypeOption = document.createElement('option');
        allTypeOption.value = '';
        allTypeOption.textContent = 'All';
        typeFilter.appendChild(allTypeOption);

        Array.from(types).sort().forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = typeLabels[type] || type;
            if (type === 'journalArticle') option.selected = true;
            typeFilter.appendChild(option);
        });
    }

    function formatAuthors(creators) {
        if (!creators) return '';
        return creators.map(c => c.name ? c.name : c.firstName && c.lastName ?
            `${c.firstName.split(/\s+/).map(name => name.charAt(0).toUpperCase() + '.').join(' ')} ${c.lastName}` :
            c.lastName || c.firstName || '').filter(name => name.trim() !== '').join(', ');
    }

    function escapeBibTeX(str) { return str?.replace(/([{}%&_#])/g, '\\$1') || ''; }

    function formatCitation(item, index, total) {
        const d = item.data, creators = d.creators || [], authors = creators.filter(c => c.creatorType === 'author'), editors = creators.filter(c => c.creatorType === 'editor');
        let mainContributors = (d.itemType === 'computerProgram' || d.itemType === "presentation") ? creators : authors;
        const formattedAuthors = formatAuthors(mainContributors);
        const formattedEditors = editors.length > 0 ? formatAuthors(editors) : null;
        const year = extractYear(d.date), number = total - index, sentenceTitle = toSentenceCasePreserveBracesAcronymsElements(d.title);
        let citation = `[${number}] ${formattedAuthors}`;
        if (d.itemType === 'computerProgram') citation += ` (${mainContributors.length === 1 ? 'contributor' : 'contributors'})`;
        citation += `. “${sentenceTitle}.”`;
        if (d.itemType === 'book') citation += ` <span class="underline">${d.bookTitle || d.title}</span>`;
        if (d.itemType === 'thesis') { citation += ` ${d.thesisType || "Thesis"}`; if (d.university) citation += `, ${d.university}`; if (d.place) citation += `, ${d.place}`; }
        if (d.itemType === 'report') { if (d.reportNumber) citation += ` Report No. ${d.reportNumber}`; if (d.place) citation += `, ${d.place}`; if (d.institution) citation += `: ${d.institution}.`; }
        if (d.itemType === 'computerProgram') { if (d.version) citation += ` Version ${d.version}`; if (d.date) citation += ` ${d.date}`; if (d.place) citation += `, ${d.place}`; if (d.institution) citation += `: ${d.institution}.`; }
        if (d.itemType === 'conferencePaper' || d.itemType === 'proceedingsArticle') { if (d.proceedingsTitle) citation += ` In <span class="italic">${d.proceedingsTitle}</span>`; if (editors.length > 0) citation += `. ${formattedEditors} (${editors.length === 1 ? 'ed.' : 'eds.'})`; if (d.place) citation += `. ${d.place}`; if (d.publisher) citation += `: ${d.publisher}`; }
        if (d.publicationTitle) citation += ` <span class="italic">${d.publicationTitle}</span>`;
        if (d.volume) citation += ` <span class="bold">${d.volume}</span>`;
        if (d.issue) citation += `(${d.issue})`;
        if (d.itemType === 'presentation') { if (d.presentationType) citation += ` ${d.presentationType}`; if (d.meetingName) citation += ` at <span class="italic">${d.meetingName}</span>`; if (d.place) citation += `, ${d.place}`; if (d.date) citation += `, ${d.date}`; }
        if (year) citation += ` (${year})`;
        if (d.pages) citation += ` p.${d.pages}`;
        if (!citation.trim().endsWith('.')) citation += '.';
        if (d.DOI) citation += ` <a href="https://doi.org/${d.DOI}" target="_blank">doi:${d.DOI}</a>`;
        else if (d.url) citation += ` <a href="${d.url}" target="_blank">${d.url}</a>`;
        return `<div class="citation">${citation}</div>`;
    }

    function convertToBibTeX(d) {
        const type = d.itemType || 'article', fields= [], key = `${d.creators?.[0]?.lastName || 'unknown'}${extractYear(d.date)}`;
        if (d.title) fields.push(`  title = {${escapeBibTeX(d.title)}}`);
        if (d.creators) { const authors = d.creators.map(c => `${c.lastName}, ${c.firstName}`).join(' and '); if (authors) fields.push(`  author = {${authors}}`); }
        if (d.publicationTitle) fields.push(`  journal = {${d.publicationTitle}}`);
        if (d.bookTitle) fields.push(`  booktitle = {${d.bookTitle}}`);
        if (d.university) fields.push(`  school = {${d.university}}`);
        if (d.date) fields.push(`  year = {${extractYear(d.date)}}`);
        if (d.volume) fields.push(`  volume = {${d.volume}}`);
        if (d.issue) fields.push(`  number = {${d.issue}}`);
        if (d.pages) fields.push(`  pages = {${d.pages}}`);
        if (d.DOI) fields.push(`  doi = {${d.DOI}}`);
        return `@${type}{${key},\n${fields.join(',\n')}\n}`;
    }
    // --- End helper functions ---

    // --- Begin main function that displays filtered bibliography
    async function displayFilteredBibliography() {
    const yearVal = document.getElementById('yearFilter').value.toLowerCase();
    const typeVal = document.getElementById('typeFilter').value;
    const searchTerm = document.getElementById('searchInput').value.toLowerCase();
    const container = document.getElementById('bibliography');

    const filtered = zoteroItems.filter(item => {
        const d = item.data;
        const year = extractYear(d.date);
        const matchesYear = yearVal ? year === yearVal : true;
        const matchesType = typeVal ? d.itemType === typeVal : true;
        const authors = formatAuthors(d.creators).toLowerCase();
        const title = (d.title || '').toLowerCase();
        const pub = (d.publicationTitle || '').toLowerCase();
        const tags = (d.tags || []).map(tag => tag.tag.toLowerCase()).join(' ');
        const matchesSearch = !searchTerm ||
        authors.includes(searchTerm) ||
        title.includes(searchTerm) ||
        pub.includes(searchTerm) ||
        tags.includes(searchTerm);
        return matchesYear && matchesType && matchesSearch;
    });

    // Render citations without OA icons yet
    container.innerHTML = filtered.map((item, index) =>
        formatCitation(item, index, filtered.length)
    ).join('') || '<p>No matching entries found.</p>';

    // Query OpenAlex for DOIs with OA data
    const doiMap = {};
    const dois = filtered
        .map((item, idx) => {
        if (item.data.DOI) {
            const doi = item.data.DOI.toLowerCase();
            doiMap[doi] = idx;
            return doi;
        }
        return null;
        })
        .filter(Boolean);

        if (dois.length > 0) {
        try {
            // Helper to split into chunks of max size n
            const chunkArray = (arr, size) =>
            arr.reduce((acc, _, i) => (i % size ? acc : [...acc, arr.slice(i, i + size)]), []);

            const doiChunks = chunkArray(dois, 100);

            const fetchPromises = doiChunks.map(async chunk => {
            const filterParam = chunk.map(d => `${encodeURIComponent(d)}`).join('|');
            const apiUrl = `https://api.openalex.org/works?filter=doi:${filterParam}`;
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`OpenAlex fetch failed (${response.status})`);
                const data = await response.json();
                return data.results; // array of works
            } catch (err) {
                console.warn(err.message);
                return [];
            }
            });

            const chunkResults = await Promise.all(fetchPromises);
            const works = chunkResults.flat();

            works.forEach(work => {
            const doi = (work.doi || '').replace(/^https?:\/\/doi.org\//, '').toLowerCase();
            const index = doiMap[doi];
            if (index === undefined) return;

            const citationbadge = container.children[index];

            // --- Scientometric badges ---
            if (doi) {
                const altmetricBadge = document.createElement('span');
                altmetricBadge.className = 'altmetric-embed';
                altmetricBadge.setAttribute('data-badge-type', '4');
                altmetricBadge.setAttribute('data-doi', doi);
                altmetricBadge.setAttribute('data-hide-no-mentions', 'true');
                altmetricBadge.style.display = 'inline-block';
                altmetricBadge.style.marginLeft = '6px';
                citationbadge.appendChild(altmetricBadge);

                const dimensionsBadge = document.createElement('span');
                dimensionsBadge.className = "__dimensions_badge_embed__";
                dimensionsBadge.setAttribute('data-style', 'small_rectangle');
                dimensionsBadge.setAttribute('data-doi', doi);
                dimensionsBadge.setAttribute('data-hide-zero-citations', 'true');
                dimensionsBadge.style.display = 'inline-block';
                dimensionsBadge.style.marginLeft = '6px';
                citationbadge.appendChild(dimensionsBadge);

                if (typeof _altmetric_embed_init === 'function') _altmetric_embed_init();
                if (window.DimensionsBadge?.render) window.DimensionsBadge.render();
            }

            // --- OA icon & PDF detection ---
            if (work.open_access?.is_oa && work.open_access.oa_url) {
                const oaUrl = work.open_access.oa_url;
                const oaStatus = work.open_access.oa_status || 'unknown';

                const oaLink = document.createElement('a');
                oaLink.href = oaUrl;
                oaLink.target = '_blank';
                oaLink.className = 'oa-icon-link oa-icon ' + oaColorClass(oaStatus);

                const oaIcon = document.createElement('span');
                oaIcon.className = 'iconify';
                oaIcon.setAttribute('data-icon', 'academicons:open-access');
                oaIcon.setAttribute('data-width', '20');
                oaIcon.setAttribute('data-height', '20');

                oaLink.appendChild(oaIcon);
                citationbadge.appendChild(oaLink);
                Iconify.scan();

                const oaUrls = work.open_access?.oa_urls || [];
                const pdfRegex = /\.pdf(\?|$)/i;
                let pdfUrl = null;
                if (oaUrls.length > 0) {
                const pdfEntry = oaUrls.find(entry => pdfRegex.test(entry.url));
                if (pdfEntry) pdfUrl = pdfEntry.url;
                }
                if (!pdfUrl && pdfRegex.test(oaUrl)) pdfUrl = oaUrl;
                if (pdfUrl) {
                const pdfLink = document.createElement('a');
                pdfLink.href = pdfUrl;
                pdfLink.target = '_blank';
                pdfLink.className = 'pdf-icon-link pdf-icon';

                const pdfIcon = document.createElement('span');
                pdfIcon.className = 'iconify';
                pdfIcon.setAttribute('data-icon', 'mdi:file-pdf-box');
                pdfIcon.setAttribute('data-width', '20');
                pdfIcon.setAttribute('data-height', '20');

                pdfLink.appendChild(pdfIcon);
                citationbadge.appendChild(pdfLink);
                Iconify.scan();
                }
            }
            });

        } catch (error) {
            console.error('Error fetching OA data:', error);
        }
        }

    if (window.MathJax?.typesetPromise) {
        MathJax.typesetPromise();
    }
    }

    // Export filtered bibliography to BibTeX
    document.getElementById('exportBibtex').addEventListener('click', () => {
    const yearVal = document.getElementById('yearFilter').value;
    const typeVal = document.getElementById('typeFilter').value;
    const filtered = zoteroItems.filter(item => {
        const d = item.data;
        const year = extractYear(d.date);
        const matchesYear = yearVal ? year === yearVal : true;
        const matchesType = typeVal ? d.itemType === typeVal : true;
        return matchesYear && matchesType;
    });

    const bibtex = filtered.map(item => convertToBibTeX(item.data)).join('\n\n');
    const blob = new Blob([bibtex], { type: 'application/x-bibtex' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'bibliography.bib';
    a.click();
    URL.revokeObjectURL(url);
    });

    // Hook up filters & search
    document.getElementById('yearFilter').addEventListener('change', displayFilteredBibliography);
    document.getElementById('typeFilter').addEventListener('change', displayFilteredBibliography);
    document.getElementById('searchInput').addEventListener('input', displayFilteredBibliography);

    // Initial load
    async function displayBibliography() {
    try {
        const items = await fetchZoteroItems();
        const bibItems = items.filter(item => validTypes.has(item.data.itemType));
        bibItems.forEach(item => { item.sortDate = extractSortDate(item.data.date); });
        zoteroItems = bibItems.sort((a, b) => b.sortDate - a.sortDate);
        populateFilters(zoteroItems);
        await displayFilteredBibliography();
    } catch (err) {
        document.getElementById('bibliography').innerText = `Failed to load bibliography: ${err.message}`;
    }
    }

    displayBibliography();
</script>
<br>
<div id="bibliography" min-width="190px">
    <span class="loading-text" id="loadingMessage"></span>
</div>
</div>
```